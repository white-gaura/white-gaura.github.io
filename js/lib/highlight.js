function _typeof(t) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof(t) } function _regeneratorRuntime() { "use strict";/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime = function e() { return t }; var t = {}, e = Object.prototype, r = e.hasOwnProperty, n = Object.defineProperty || function (t, e, r) { t[e] = r.value }, o = "function" == typeof Symbol ? Symbol : {}, i = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", c = o.toStringTag || "@@toStringTag"; function u(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e] } try { u({}, "") } catch (t) { u = function t(e, r, n) { return e[r] = n } } function l(t, e, r, o) { var i = e && e.prototype instanceof h ? e : h, a = Object.create(i.prototype), c = new E(o || []); return n(a, "_invoke", { value: _(t, r, c) }), a } function f(t, e, r) { try { return { type: "normal", arg: t.call(e, r) } } catch (t) { return { type: "throw", arg: t } } } t.wrap = l; var s = {}; function h() { } function y() { } function p() { } var d = {}; u(d, i, (function () { return this })); var v = Object.getPrototypeOf, g = v && v(v(A([]))); g && g !== e && r.call(g, i) && (d = g); var m = p.prototype = h.prototype = Object.create(d); function b(t) { ["next", "throw", "return"].forEach((function (e) { u(t, e, (function (t) { return this._invoke(e, t) })) })) } function w(t, e) { function o(n, i, a, c) { var u = f(t[n], t, i); if ("throw" !== u.type) { var l = u.arg, s = l.value; return s && "object" == _typeof(s) && r.call(s, "__await") ? e.resolve(s.__await).then((function (t) { o("next", t, a, c) }), (function (t) { o("throw", t, a, c) })) : e.resolve(s).then((function (t) { l.value = t, a(l) }), (function (t) { return o("throw", t, a, c) })) } c(u.arg) } var i; n(this, "_invoke", { value: function t(r, n) { function a() { return new e((function (t, e) { o(r, n, t, e) })) } return i = i ? i.then(a, a) : a() } }) } function _(t, e, r) { var n = "suspendedStart"; return function (o, i) { if ("executing" === n) throw new Error("Generator is already running"); if ("completed" === n) { if ("throw" === o) throw i; return T() } for (r.method = o, r.arg = i; ;) { var a = r.delegate; if (a) { var c = L(a, r); if (c) { if (c === s) continue; return c } } if ("next" === r.method) r.sent = r._sent = r.arg; else if ("throw" === r.method) { if ("suspendedStart" === n) throw n = "completed", r.arg; r.dispatchException(r.arg) } else "return" === r.method && r.abrupt("return", r.arg); n = "executing"; var u = f(t, e, r); if ("normal" === u.type) { if (n = r.done ? "completed" : "suspendedYield", u.arg === s) continue; return { value: u.arg, done: r.done } } "throw" === u.type && (n = "completed", r.method = "throw", r.arg = u.arg) } } } function L(t, e) { var r = e.method, n = t.iterator[r]; if (undefined === n) return e.delegate = null, "throw" === r && t.iterator.return && (e.method = "return", e.arg = undefined, L(t, e), "throw" === e.method) || "return" !== r && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + r + "' method")), s; var o = f(n, t.iterator, e.arg); if ("throw" === o.type) return e.method = "throw", e.arg = o.arg, e.delegate = null, s; var i = o.arg; return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = undefined), e.delegate = null, s) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, s) } function x(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function S(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function E(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(x, this), this.reset(!0) } function A(t) { if (t) { var e = t[i]; if (e) return e.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var n = -1, o = function e() { for (; ++n < t.length;)if (r.call(t, n)) return e.value = t[n], e.done = !1, e; return e.value = undefined, e.done = !0, e }; return o.next = o } } return { next: T } } function T() { return { value: undefined, done: !0 } } return y.prototype = p, n(m, "constructor", { value: p, configurable: !0 }), n(p, "constructor", { value: y, configurable: !0 }), y.displayName = u(p, c, "GeneratorFunction"), t.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === y || "GeneratorFunction" === (e.displayName || e.name)) }, t.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, p) : (t.__proto__ = p, u(t, c, "GeneratorFunction")), t.prototype = Object.create(m), t }, t.awrap = function (t) { return { __await: t } }, b(w.prototype), u(w.prototype, a, (function () { return this })), t.AsyncIterator = w, t.async = function (e, r, n, o, i) { void 0 === i && (i = Promise); var a = new w(l(e, r, n, o), i); return t.isGeneratorFunction(r) ? a : a.next().then((function (t) { return t.done ? t.value : a.next() })) }, b(m), u(m, c, "Generator"), u(m, i, (function () { return this })), u(m, "toString", (function () { return "[object Generator]" })), t.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function t() { for (; r.length;) { var n = r.pop(); if (n in e) return t.value = n, t.done = !1, t } return t.done = !0, t } }, t.values = A, E.prototype = { constructor: E, reset: function t(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(S), !e) for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = undefined) }, stop: function t() { this.done = !0; var e = this.tryEntries[0].completion; if ("throw" === e.type) throw e.arg; return this.rval }, dispatchException: function t(e) { if (this.done) throw e; var n = this; function o(t, r) { return c.type = "throw", c.arg = e, n.next = t, r && (n.method = "next", n.arg = undefined), !!r } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var a = this.tryEntries[i], c = a.completion; if ("root" === a.tryLoc) return o("end"); if (a.tryLoc <= this.prev) { var u = r.call(a, "catchLoc"), l = r.call(a, "finallyLoc"); if (u && l) { if (this.prev < a.catchLoc) return o(a.catchLoc, !0); if (this.prev < a.finallyLoc) return o(a.finallyLoc) } else if (u) { if (this.prev < a.catchLoc) return o(a.catchLoc, !0) } else { if (!l) throw new Error("try statement without catch or finally"); if (this.prev < a.finallyLoc) return o(a.finallyLoc) } } } }, abrupt: function t(e, n) { for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o]; if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) { var a = i; break } } a && ("break" === e || "continue" === e) && a.tryLoc <= n && n <= a.finallyLoc && (a = null); var c = a ? a.completion : {}; return c.type = e, c.arg = n, a ? (this.method = "next", this.next = a.finallyLoc, s) : this.complete(c) }, complete: function t(e, r) { if ("throw" === e.type) throw e.arg; return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && r && (this.next = r), s }, finish: function t(e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var n = this.tryEntries[r]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), S(n), s } }, catch: function t(e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var n = this.tryEntries[r]; if (n.tryLoc === e) { var o = n.completion; if ("throw" === o.type) { var i = o.arg; S(n) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function t(e, r, n) { return this.delegate = { iterator: A(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = undefined), s } }, t } function asyncGeneratorStep(t, e, r, n, o, i, a) { try { var c = t[i](a); var u = c.value } catch (t) { r(t); return } if (c.done) { e(u) } else { Promise.resolve(u).then(n, o) } } function _asyncToGenerator(t) { return function () { var e = this, r = arguments; return new Promise((function (n, o) { var i = t.apply(e, r); function a(t) { asyncGeneratorStep(i, n, o, a, c, "next", t) } function c(t) { asyncGeneratorStep(i, n, o, a, c, "throw", t) } a(undefined) })) } } function _toConsumableArray(t) { return _arrayWithoutHoles(t) || _iterableToArray(t) || _unsupportedIterableToArray(t) || _nonIterableSpread() } function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function _iterableToArray(t) { if (typeof Symbol !== "undefined" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function _arrayWithoutHoles(t) { if (Array.isArray(t)) return _arrayLikeToArray(t) } function _createForOfIteratorHelper(t, e) { var r = typeof Symbol !== "undefined" && t[Symbol.iterator] || t["@@iterator"]; if (!r) { if (Array.isArray(t) || (r = _unsupportedIterableToArray(t)) || e && t && typeof t.length === "number") { if (r) t = r; var n = 0; var o = function t() { }; return { s: o, n: function e() { if (n >= t.length) return { done: true }; return { done: false, value: t[n++] } }, e: function t(e) { throw e }, f: o } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var i = true, a = false, c; return { s: function e() { r = r.call(t) }, n: function t() { var e = r.next(); i = e.done; return e }, e: function t(e) { a = true; c = e }, f: function t() { try { if (!i && r.return != null) r.return() } finally { if (a) throw c } } } } function _unsupportedIterableToArray(t, e) { if (!t) return; if (typeof t === "string") return _arrayLikeToArray(t, e); var r = Object.prototype.toString.call(t).slice(8, -1); if (r === "Object" && t.constructor) r = t.constructor.name; if (r === "Map" || r === "Set") return Array.from(t); if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return _arrayLikeToArray(t, e) } function _arrayLikeToArray(t, e) { if (e == null || e > t.length) e = t.length; for (var r = 0, n = new Array(e); r < e; r++)n[r] = t[r]; return n } mixins.highlight = { data: function t() { return { copying: false } }, created: function t() { hljs.configure({ ignoreUnescapedHTML: true }); this.renderers.push(this.highlight) }, methods: { sleep: function t(e) { return new Promise((function (t) { return setTimeout(t, e) })) }, highlight: function t() { var e = this; var r = document.querySelectorAll("pre"); var n = _createForOfIteratorHelper(r), o; try { var i = function t() { var r = o.value; var n = r.textContent; var i = [].concat(_toConsumableArray(r.classList), _toConsumableArray(r.firstChild.classList))[0] || "plaintext"; var a; try { a = hljs.highlight(n, { language: i }).value } catch (t) { a = n } r.innerHTML = '\n                    <div class="code-content hljs">'.concat(a, '</div>\n                    <div class="language">').concat(i, '</div>\n                    <div class="copycode">\n                        <i class="fa-solid fa-copy fa-fw"></i>\n                        <i class="fa-solid fa-clone fa-fw"></i>\n                    </div>\n                '); var c = r.querySelector(".code-content"); hljs.lineNumbersBlock(c, { singleLine: true }); var u = r.querySelector(".copycode"); u.addEventListener("click", _asyncToGenerator(_regeneratorRuntime().mark((function t() { return _regeneratorRuntime().wrap((function t(r) { while (1) switch (r.prev = r.next) { case 0: if (!e.copying) { r.next = 2; break } return r.abrupt("return"); case 2: e.copying = true; u.classList.add("copied"); r.next = 6; return navigator.clipboard.writeText(n); case 6: r.next = 8; return e.sleep(1e3); case 8: u.classList.remove("copied"); e.copying = false; case 10: case "end": return r.stop() } }), t) })))) }; for (n.s(); !(o = n.n()).done;) { i() } } catch (t) { n.e(t) } finally { n.f() } } } };